<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lynker Spatial">
<meta name="dcterms.date" content="2025-06-13">

<title>Data Processing Steps for RiverML</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#step-1-preparing-input-data." id="toc-step-1-preparing-input-data." class="nav-link" data-scroll-target="#step-1-preparing-input-data.">Step 1: Preparing Input Data.</a>
  <ul class="collapse">
  <li><a href="#load-packages-and-define-helper-functions" id="toc-load-packages-and-define-helper-functions" class="nav-link" data-scroll-target="#load-packages-and-define-helper-functions">Load Packages and Define Helper Functions</a></li>
  <li><a href="#reference-data-paths-and-setup" id="toc-reference-data-paths-and-setup" class="nav-link" data-scroll-target="#reference-data-paths-and-setup">Reference Data Paths and Setup</a></li>
  <li><a href="#process-each-submodel-with-transect-processing-loop" id="toc-process-each-submodel-with-transect-processing-loop" class="nav-link" data-scroll-target="#process-each-submodel-with-transect-processing-loop">Process Each Submodel with Transect Processing Loop</a></li>
  <li><a href="#merge-all-data" id="toc-merge-all-data" class="nav-link" data-scroll-target="#merge-all-data">Merge all data</a></li>
  <li><a href="#extract-representative-cross-section" id="toc-extract-representative-cross-section" class="nav-link" data-scroll-target="#extract-representative-cross-section">Extract Representative Cross Section</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  <li><a href="#step-2-training-machine-learning-ml-model" id="toc-step-2-training-machine-learning-ml-model" class="nav-link" data-scroll-target="#step-2-training-machine-learning-ml-model">Step 2: Training Machine Learning (ML) model</a>
  <ul class="collapse">
  <li><a href="#preprocessing" id="toc-preprocessing" class="nav-link" data-scroll-target="#preprocessing">Preprocessing:</a></li>
  <li><a href="#ml-training" id="toc-ml-training" class="nav-link" data-scroll-target="#ml-training">ML Training</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  </ul></li>
  <li><a href="#skill-comparision-to-hydroswot-base-riverml" id="toc-skill-comparision-to-hydroswot-base-riverml" class="nav-link" data-scroll-target="#skill-comparision-to-hydroswot-base-riverml">Skill comparision to HydroSWOT base riverML</a>
  <ul class="collapse">
  <li><a href="#width" id="toc-width" class="nav-link" data-scroll-target="#width">Width</a></li>
  <li><a href="#depth" id="toc-depth" class="nav-link" data-scroll-target="#depth">Depth</a></li>
  <li><a href="#shape" id="toc-shape" class="nav-link" data-scroll-target="#shape">Shape</a></li>
  </ul></li>
  <li><a href="#final-data-access" id="toc-final-data-access" class="nav-link" data-scroll-target="#final-data-access">Final Data Access</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Processing Steps for RiverML</h1>
<p class="subtitle lead">Using FEMA BLE models to inform ML estimates of channel size and shape</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lynker Spatial </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 13, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="overview" class="level1">
<h1>Overview</h1>
<p>This document processes a collection of hydraulic model outputs (in this case, FEMA BLE submodels stored as .gpkg files) to extract and compute representative channel cross-section (XS) characteristics for each river reach within a hydrologic unit. It combines geospatial data manipulation with hydrologic geometry analysis to generate useful channel metrics for modeling or further analysis.</p>
</section>
<section id="step-1-preparing-input-data." class="level1">
<h1>Step 1: Preparing Input Data.</h1>
<p>This example processes elevation profile data from FEMA BLE submodels, extracting key cross-sectional (XS) geometry attributes for hydraulic analysis. The overall goal is to compute summary statistics and representative cross-sections per stream reach in the reference fabric, so that it can be used within the existing riverML framework for predicting channel size and shape.</p>
<section id="load-packages-and-define-helper-functions" class="level2">
<h2 class="anchored" data-anchor-id="load-packages-and-define-helper-functions">Load Packages and Define Helper Functions</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load required packages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="do">## 1. Elevation Smoothing Utility</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># - Purpose: Smooth noisy elevation values within a transect.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># - How it works: If an elevation value exceeds a threshold, it’s replaced with the average of its neighboring values (unless it’s at the edge, then it’s copied from one neighbor).</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># - Why: Helps remove spikes or artifacts in cross-section profiles, which could bias geometry-based calculations.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>clean_elev <span class="ot">&lt;-</span> <span class="cf">function</span>(elev_vec, <span class="at">threshold =</span> <span class="dv">100</span>) {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">which</span>(elev_vec <span class="sc">&gt;</span> threshold)) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i <span class="sc">&gt;</span> <span class="dv">1</span> <span class="sc">&amp;&amp;</span> i <span class="sc">&lt;</span> <span class="fu">length</span>(elev_vec)) {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      elev_vec[i] <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">c</span>(elev_vec[i <span class="sc">-</span> <span class="dv">1</span>], elev_vec[i <span class="sc">+</span> <span class="dv">1</span>]), <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (i <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      elev_vec[i] <span class="ot">&lt;-</span> elev_vec[i <span class="sc">+</span> <span class="dv">1</span>]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (i <span class="sc">==</span> <span class="fu">length</span>(elev_vec)) {</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      elev_vec[i] <span class="ot">&lt;-</span> elev_vec[i <span class="sc">-</span> <span class="dv">1</span>]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  elev_vec</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="do">## 2. Channel Area Calculation</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># - Purpose: Compute the cross-sectional channel area from a transect up to a given depth.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># - How it works: Uses the AUC (Area Under Curve) difference between the water surface and the bed profile.</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># - Why: The result is used to calculate the hydraulic radius and describe the channel’s shape.</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>.findCA <span class="ot">&lt;-</span> <span class="cf">function</span>(df, depth) {</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> <span class="fu">filter</span>(df, Y <span class="sc">&lt;=</span> depth)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressWarnings</span>({</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> <span class="fu">pmax</span>(</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span>, </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      DescTools<span class="sc">::</span><span class="fu">AUC</span>(<span class="at">x =</span> t<span class="sc">$</span>x, <span class="at">y =</span> <span class="fu">rep</span>(depth, <span class="fu">nrow</span>(t)), <span class="at">absolutearea =</span> <span class="cn">FALSE</span>) <span class="sc">-</span> </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        DescTools<span class="sc">::</span><span class="fu">AUC</span>(<span class="at">x =</span> t<span class="sc">$</span>x, <span class="at">y =</span> t<span class="sc">$</span>Y, <span class="at">absolutearea =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ifelse</span>(<span class="fu">is.na</span>(x), <span class="dv">0</span>, x)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="reference-data-paths-and-setup" class="level2">
<h2 class="anchored" data-anchor-id="reference-data-paths-and-setup">Reference Data Paths and Setup</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set file paths</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="do">## v3.0 reference fabric ...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ref_path <span class="ot">&lt;-</span> <span class="st">"/Users/mikejohnson/hydrofabric/v3.0/reference_fabric.gpkg"</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Full MIP archive shared with us ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>fema     <span class="ot">&lt;-</span> <span class="st">'/Volumes/MyBook/mip_full_collection/'</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># In the full example, we would loop over all ble_model directories ...</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>dir      <span class="ot">&lt;-</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"{fema}/ble_05119_Pulaski/submodels"</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Discover and annotate submodel files ...</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># - Purpose: Traverse a directory of FEMA BLE submodels to gather all .gpkg files.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># - Result: A table where each row contains metadata (e.g., reach name, file path) for a submodel.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>subs <span class="ot">&lt;-</span> <span class="fu">list.files</span>(dir, <span class="at">recursive =</span> <span class="cn">TRUE</span>, <span class="at">pattern =</span> <span class="st">".gpkg$"</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>) <span class="sc">|&gt;</span> </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span> </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setNames</span>(<span class="st">"file"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">reach =</span> <span class="fu">gsub</span>(<span class="st">'.*/'</span>, <span class="st">''</span>, file),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">reach =</span> <span class="fu">gsub</span>(<span class="st">'.gpkg'</span>, <span class="st">''</span>, reach),</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">name =</span> <span class="fu">gsub</span>(<span class="st">'/submodels'</span>, <span class="st">""</span>, <span class="fu">gsub</span>(fema, <span class="st">""</span>, dir))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(subs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 184
Columns: 3
$ file  &lt;chr&gt; "/Volumes/MyBook/mip_full_collection//ble_05119_Pulaski/submodel…
$ reach &lt;chr&gt; "15312271", "15312277", "15312287", "15312297", "15312309", "153…
$ name  &lt;glue&gt; "/ble_05119_Pulaski", "/ble_05119_Pulaski", "/ble_05119_Pulaski…</code></pre>
</div>
</div>
</section>
<section id="process-each-submodel-with-transect-processing-loop" class="level2">
<h2 class="anchored" data-anchor-id="process-each-submodel-with-transect-processing-loop">Process Each Submodel with Transect Processing Loop</h2>
<p>For each submodel: - Read the cross-sections (XS) and transform them into a common CRS (EPSG:5070).</p>
<p>For each transect: - Parse and clean the raw string of elevation points. - Identify left/right bank extents. - Subset the relevant portion and smooth the elevation. - Filter out degenerate transects (e.g., no real depth). - Compute metrics: - Ym: channel depth - TW: top width - A: channel area - r: Dingmans R coefficient - Save it as a geometry object with selected metadata. - Also extracts metadata like the coordinate system units and stores them for each reach.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>subs_data <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (v <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(subs)) {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">message</span>(<span class="st">"</span><span class="sc">\t</span><span class="st">Processing "</span>, <span class="fu">basename</span>(subs<span class="sc">$</span>file[v]), <span class="st">" ("</span>, v ,<span class="st">" in "</span>, <span class="fu">nrow</span>(subs), <span class="st">")"</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Read XS layer from submodel and transform to projected CRS</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  transects <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(<span class="fu">read_sf</span>(subs<span class="sc">$</span>file[v], <span class="st">'XS'</span>), <span class="dv">5070</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  ll <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(transects)) {</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parse and clean station-elevation profile</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    cleaned <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">[|</span><span class="sc">\\</span><span class="st">]|</span><span class="sc">\\</span><span class="st">(|</span><span class="sc">\\</span><span class="st">)"</span>, <span class="st">""</span>, transects<span class="sc">$</span>station_elevation_points[j])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    cleaned <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(cleaned, <span class="st">", "</span>)[[<span class="dv">1</span>]]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">matrix</span>(<span class="fu">as.numeric</span>(cleaned), <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>))</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">names</span>(df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"Y"</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract left/right bank stations</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    pins <span class="ot">&lt;-</span> transects<span class="sc">$</span>bank_stations[j] <span class="sc">%&gt;%</span> </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">gsub</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">[|</span><span class="sc">\\</span><span class="st">]|</span><span class="sc">\\</span><span class="st">'"</span>, <span class="st">""</span>, .) <span class="sc">|&gt;</span> </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">strsplit</span>(<span class="st">",</span><span class="sc">\\</span><span class="st">s*"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>      <span class="fu">unlist</span>() <span class="sc">|&gt;</span> </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">as.numeric</span>()</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Subset profile to only between banks and clean elevation</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">filter</span>(df, dplyr<span class="sc">::</span><span class="fu">between</span>(x, pins[<span class="dv">1</span>], pins[<span class="dv">2</span>])) </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    result<span class="sc">$</span>Y <span class="ot">&lt;-</span> <span class="fu">clean_elev</span>(result<span class="sc">$</span>Y)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">nrow</span>(result) <span class="sc">&lt;=</span> <span class="dv">2</span> <span class="sc">|</span> <span class="fu">diff</span>(<span class="fu">range</span>(result<span class="sc">$</span>Y)) <span class="sc">&lt;</span> .<span class="dv">25</span>) {</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>      <span class="fu">warning</span>(<span class="st">"No channel in transect "</span>, j, <span class="st">" for "</span>, <span class="fu">basename</span>(subs<span class="sc">$</span>file[v]))</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Compute channel geometry attributes</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>Ym <span class="ot">&lt;-</span> <span class="fu">max</span>(result<span class="sc">$</span>Y) <span class="sc">-</span> <span class="fu">min</span>(result<span class="sc">$</span>Y)  <span class="co"># channel depth</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>TW <span class="ot">&lt;-</span> <span class="fu">max</span>(result<span class="sc">$</span>x) <span class="sc">-</span> <span class="fu">min</span>(result<span class="sc">$</span>x)  <span class="co"># top width</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>flowpath_id <span class="ot">&lt;-</span> subs<span class="sc">$</span>reach[v]</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>river_station <span class="ot">&lt;-</span> transects<span class="sc">$</span>river_station[j] </span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>model <span class="ot">=</span> subs<span class="sc">$</span>file[v]</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>A <span class="ot">&lt;-</span> <span class="fu">.findCA</span>(result, <span class="fu">max</span>(result<span class="sc">$</span>Y))  <span class="co"># channel area</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>r <span class="ot">&lt;-</span> result<span class="sc">$</span>A <span class="sc">/</span> ((result<span class="sc">$</span>Ym <span class="sc">*</span> result<span class="sc">$</span>TW) <span class="sc">-</span> result<span class="sc">$</span>A)  <span class="co"># Dingmans R shape</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>      result<span class="sc">$</span>domain <span class="ot">&lt;-</span> subs<span class="sc">$</span>name[v]</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Join metadata and convert to spatial</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>      ll[[j]] <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">distinct</span>(dplyr<span class="sc">::</span><span class="fu">select</span>(result, <span class="sc">-</span>x, <span class="sc">-</span>Y)) <span class="sc">|&gt;</span> </span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="fu">slice</span>(<span class="dv">1</span>) <span class="sc">|&gt;</span> </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        <span class="fu">left_join</span>(</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>          <span class="fu">select</span>(transects[j,], </span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>                 river_station, river_reach_rs, </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>                 source_river, source_reach, source_river_station, station_elevation_points, bank_stations ),</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>          <span class="at">by =</span> <span class="fu">c</span>(<span class="st">'river_station'</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        ) <span class="sc">|&gt;</span> </span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        <span class="fu">st_as_sf</span>()</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Try reading metadata layer for units</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>  meta <span class="ot">=</span> <span class="fu">suppressWarnings</span>({</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tryCatch</span>({<span class="fu">read_sf</span>(subs<span class="sc">$</span>file[v], <span class="st">'metadata'</span>) <span class="sc">|&gt;</span> <span class="fu">filter</span>(key <span class="sc">==</span> <span class="st">"units"</span>)},</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>             <span class="at">error =</span> <span class="cf">function</span>(e) { <span class="fu">data.frame</span>(<span class="at">value =</span> <span class="cn">NA</span>) })</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create CRS and units metadata</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>  meta <span class="ot">=</span> meta <span class="sc">|&gt;</span> </span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">flowpath_id =</span> subs<span class="sc">$</span>reach[v],</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>           <span class="at">epsg =</span> <span class="fu">st_crs</span>(<span class="fu">read_sf</span>(subs<span class="sc">$</span>file[v], <span class="st">'XS'</span>))<span class="sc">$</span>epsg,</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>           <span class="at">crs_units =</span> <span class="fu">st_crs</span>(<span class="fu">read_sf</span>(subs<span class="sc">$</span>file[v], <span class="st">'XS'</span>))<span class="sc">$</span>units) <span class="sc">|&gt;</span> </span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(flowpath_id, <span class="at">metdata_units =</span> value, epsg, crs_units)</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>  fin <span class="ot">=</span> <span class="fu">bind_rows</span>(ll)</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Store only if valid data</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">nrow</span>(fin) <span class="sc">&gt;</span> <span class="dv">0</span> <span class="sc">&amp;</span> <span class="fu">nrow</span>(meta) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>    subs_data[[v]] <span class="ot">&lt;-</span> <span class="fu">left_join</span>(fin, meta, <span class="at">by =</span> <span class="st">"flowpath_id"</span>)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    subs_data[[v]] <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="merge-all-data" class="level2">
<h2 class="anchored" data-anchor-id="merge-all-data">Merge all data</h2>
<p>All cleaned and processed transect data are combined into one table, now representing all relevant reaches in the HUC.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>huc_xs <span class="ot">&lt;-</span> <span class="fu">tibble</span>(data.table<span class="sc">::</span><span class="fu">rbindlist</span>(subs_data)) <span class="sc">|&gt;</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(huc_xs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 1,344
Columns: 18
$ Ym                       &lt;dbl&gt; 1.1250000, 1.1525000, 1.6121484, 1.8548437, 1…
$ TW                       &lt;dbl&gt; 40.02, 41.57, 70.00, 50.22, 40.02, 40.56, 40.…
$ flowpath_id              &lt;chr&gt; "15312271", "15312271", "15312277", "15312277…
$ river_station            &lt;dbl&gt; 1, 2, 1, 2, 3, 1, 2, 3, 4, 5, 6, 7, 1, 2, 1, …
$ model                    &lt;chr&gt; "/Volumes/MyBook/mip_full_collection//ble_051…
$ A                        &lt;dbl&gt; 25.32970, 28.43397, 77.29426, 61.00897, 25.32…
$ r                        &lt;dbl&gt; 1.2862413, 1.4599895, 2.1738658, 1.8981500, 1…
$ domain                   &lt;chr&gt; "/ble_05119_Pulaski", "/ble_05119_Pulaski", "…
$ river_reach_rs           &lt;chr&gt; "littleck Reach 1 1", "littleck Reach 1 2", "…
$ source_river             &lt;chr&gt; "littleck", "littleck", "littleck", "littleck…
$ source_reach             &lt;chr&gt; "Reach 1", "Reach 1", "Reach 1", "Reach 1", "…
$ source_river_station     &lt;dbl&gt; 27643.05000, 30516.51000, 22751.30000, 25430.…
$ station_elevation_points &lt;chr&gt; "[(0.0, 421.34), (10.0, 418.82), (19.99, 417.…
$ bank_stations            &lt;chr&gt; "['2382.91', '2422.93']", "['1813.19', '1854.…
$ metdata_units            &lt;chr&gt; "English", "English", "English", "English", "…
$ epsg                     &lt;int&gt; 3434, 3434, 3434, 3434, 3434, 3442, 3442, 344…
$ crs_units                &lt;chr&gt; "us-ft", "us-ft", "us-ft", "us-ft", "us-ft", …
$ geom                     &lt;LINESTRING [m]&gt; LINESTRING (341922.1 133235..., LI…</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#mapview::mapview(st_as_sf(huc_xs))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="extract-representative-cross-section" class="level2">
<h2 class="anchored" data-anchor-id="extract-representative-cross-section">Extract Representative Cross Section</h2>
<p>Each reach may have multiple transects. This code a representative transect per reach: - Takes the median one (by river station order). - Computes mean values for width, depth, and shape ratio. - Keeps geometry and other context attributes from that central transect.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute representative XS features per flowpath</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>representive_features <span class="ot">&lt;-</span> huc_xs <span class="sc">|&gt;</span> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  tidyr<span class="sc">::</span><span class="fu">drop_na</span>(flowpath_id) <span class="sc">|&gt;</span> </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">group_by</span>(flowpath_id) <span class="sc">|&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(river_station) <span class="sc">|&gt;</span> </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">summarise</span>(</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">r  =</span> <span class="fu">mean</span>(r[<span class="fu">is.finite</span>(r)]),</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">TW =</span> <span class="fu">mean</span>(TW),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">Y  =</span> <span class="fu">mean</span>(Ym),</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">geom =</span> geom[<span class="fu">ceiling</span>(<span class="fu">n</span>()<span class="sc">/</span><span class="dv">2</span>)],</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">source_river_station =</span> source_river_station[<span class="fu">ceiling</span>(<span class="fu">n</span>()<span class="sc">/</span><span class="dv">2</span>)],</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">river_station =</span> river_station[<span class="fu">ceiling</span>(<span class="fu">n</span>()<span class="sc">/</span><span class="dv">2</span>)],</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> model[<span class="fu">ceiling</span>(<span class="fu">n</span>()<span class="sc">/</span><span class="dv">2</span>)])</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>nhd_meta <span class="ot">&lt;-</span> nhdplusTools<span class="sc">::</span><span class="fu">get_vaa</span>(<span class="fu">c</span>(<span class="st">'ftype'</span>, <span class="st">'streamorde'</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">comid =</span> <span class="fu">as.character</span>(comid))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>out_xs <span class="ot">&lt;-</span> representive_features <span class="sc">|&gt;</span> </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(nhd_meta, <span class="at">by =</span> <span class="fu">c</span>(<span class="st">'flowpath_id'</span> <span class="ot">=</span> <span class="st">'comid'</span>))</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(out_xs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 170
Columns: 10
$ flowpath_id          &lt;chr&gt; "15312271", "15312277", "15312287", "15312297", "…
$ r                    &lt;dbl&gt; 1.3731154, 1.7860857, 3.3466956, 1.8001889, 2.223…
$ TW                   &lt;dbl&gt; 40.79500, 53.41333, 51.90571, 42.78500, 63.75250,…
$ Y                    &lt;dbl&gt; 1.1387500, 1.5306641, 1.2434375, 1.4540625, 1.344…
$ geom                 &lt;LINESTRING [m]&gt; LINESTRING (341922.1 133235..., LINEST…
$ source_river_station &lt;dbl&gt; 27643.0500, 25430.9000, 2511.1050, 37525.9500, 21…
$ river_station        &lt;dbl&gt; 1, 2, 4, 1, 2, 2, 1, 6, 7, 1, 3, 1, 4, 3, 9, 1, 3…
$ model                &lt;chr&gt; "/Volumes/MyBook/mip_full_collection//ble_05119_P…
$ ftype                &lt;chr&gt; "StreamRiver", "StreamRiver", "StreamRiver", "Str…
$ streamorde           &lt;dbl&gt; 1, 2, 1, 1, 2, 2, 2, 1, 3, 3, 3, 3, 2, 1, 1, 2, 1…</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ref_fab <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(ref_path, <span class="st">"flowpaths"</span>, <span class="at">wkt_filter =</span> <span class="fu">st_as_text</span>(<span class="fu">st_as_sfc</span>(<span class="fu">st_bbox</span>(<span class="fu">st_union</span>(huc_xs))))) </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#mapview::mapview(out_xs, color = "red") + ref_fab</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>–&gt; Inputs: FEMA BLE submodels as .gpkg files containing cross-section data, Reference hydrofabric (flowlines)</p>
<p>–&gt; Outputs: Processed cross-section attributes per reach, One representative XS per flowpath, Joined metadata from hydraulic units and NHDPlus</p>
<p>–&gt; Clean, analysis-ready datasets</p>
<p>–&gt; The full looped run can be found <a href="https://github.com/lynker-spatial/mip-riverml/blob/main/mip-processing.R">here</a></p>
</section>
</section>
<section id="step-2-training-machine-learning-ml-model" class="level1">
<h1>Step 2: Training Machine Learning (ML) model</h1>
<p>Here we outline the results from using new RAS information to update channel dimension characteristics in the riverML model first shared <a href="https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2024JH000173">here</a>.</p>
<p>The goal is to enhance CONUS-wide estimates of bankfull river channel geometry by training ML models on a Ripple and HydroSWOT combined datasets. The models predict three key parameters that provide a simplified yet comprehensive representation of channel shape: top-width (TW), mean depth (Y), and a shape (r).</p>
<section id="preprocessing" class="level2">
<h2 class="anchored" data-anchor-id="preprocessing">Preprocessing:</h2>
<p>The initial dataset was significantly expanded by incorporating new Ripple RAS data, increasing the potential training instances from ~3,000 (HydroSWOT) to ~70,000.</p>
<p>Our reprocessing steps included:</p>
<p><strong>Parameter Extraction</strong>: Bankfull TW and Y were extracted directly from RAS models (see step 1). All measurements were unified in units via projection transformation / scaleing where needed.</p>
<p><strong>Spatial Aggregation</strong>: Data points were averaged to the river reach scale to align with the hydrofabric, reducing the dataset to ~140,000 unique reaches. This new data provides substantially greater coverage in the central U.S. (especially Texas) and critically expands the representation of low-order streams (orders 1-3), Coastal domain, lakes, and reservoirs which were sparse in the original HydroSWOT dataset.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig1.png" class="img-fluid figure-img" width="676"></p>
<figcaption>Figure 1: Comparison of HydroSWOT and Ripple RAS data coverage across CONUS.</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Quality Control and Filtering</strong>: A comparison between RAS-derived top-widths and a comprehensive, satellite-derived reference dataset (data fusion TW; dfTW) revealed significant discrepancies. To remove anomalous data points, a filtering threshold was applied:</p>
<p><span class="math display">
0.75 ✕ dfTW ≤ rasTW ≤ 5 ✕ dfTW.
</span></p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig2.png" class="img-fluid figure-img" width="498"></p>
<figcaption>Figure 2: Before and after filtering.</figcaption>
</figure>
</div>
</div>
</div>
<p>This essential cleaning step reduced the dataset to ~70,000 high-confidence reaches. The majority of filtered data (~44%) originated from stream orders 1-3, which also exhibited the largest error magnitudes prior to cleaning.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig3.png" class="img-fluid figure-img" width="626"></p>
<figcaption>Figure 3: Reduction in primary dataset based on above threshold by streamorder.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="ml-training" class="level2">
<h2 class="anchored" data-anchor-id="ml-training">ML Training</h2>
<p>The filtered Ripple RAS data was combined with the HydroSWOT data. This final dataset was partitioned into 70% for training, 15% for validation, and 15% for testing. Three separate ML models were developed for TW, Y, and r. Cross-validation was employed to optimize hyperparameters and prevent overfitting. The trained models were then used to infer channel geometry for all ~2.7 million river reaches across the CONUS.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The inclusion of diverse training data has markedly improved model performance and generalization.</p>
<p><strong>Quantitative Performance</strong>: The models demonstrate excellent agreement with ground-truth values on the unseen test dataset, confirming their predictive skill. When evaluated against the test data, the new ML models show a significant improvement in skill for TW and Y across all Hydrological Landscape Regions (HLRs; bar plots) compared to the drainage area based Blackburn-Lynch (2017) equations used in the National Water Model (black dots within bar plots).</p>
<p><strong>Improved Geographic and Typological Representation</strong>: The previous ML models lacked data for river reaches influenced by coastal zones, lakes, or reservoirs, where channel widening and depth profiles behave uniquely. The new models were trained on such reaches and use river classification added as a predictive feature, enabling more accurate estimates in these complex transition zones.</p>
<p><strong>Qualitative Validation</strong>: Visual inspection of CONUS-wide maps of the predicted TW, Y, and r reveals coherent, large-scale fluvial patterns that align with known river characteristics across CONUS. This provides strong qualitative confidence that the models have successfully learned the underlying dynamics of river channel formation across different climates and landscapes.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig4.png" class="img-fluid figure-img" width="738"></p>
<figcaption>Figure 4: ML estimates for TW.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig5.png" class="img-fluid figure-img" width="731"></p>
<figcaption>Figure 5: ML estimates for Y.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig6.png" class="img-fluid figure-img" width="752"></p>
<figcaption>Figure 6: ML estimates for r.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="skill-comparision-to-hydroswot-base-riverml" class="level1">
<h1>Skill comparision to HydroSWOT base riverML</h1>
<p>A comparison is conducted using unseen test data between the updated machine learning (ML) estimates from Ripple and the earlier HydroSWOT-derived channel characteristics at bankfull conditions. However, it is important to note that the definition of bankfull conditions differs between the HydroSWOT training dataset and Ripple RAS data. In HydroSWOT, bankfull is defined as a flood event with a 50% annual exceedance probability (AEP), whereas Ripple relies on RAS-based classification of bankfull. Consequently, this comparison is not strictly one-to-one but rather an approximation across the two datasets. The same principle applies to derivative variables such as channel top-width, depth, and shape.</p>
<p>We compare results across three categories of flowlines: Inland, Coastal, and Lakes/Reservoirs. The <a href="https://doi.org/10.1029/2024JH000173">previous model</a> exhibited lower accuracy in Coastal and Lakes/Reservoirs due to data limitations. In contrast, the updated Ripple dataset provides improved representation of lakes, reservoirs, and coastal areas. As expected, we observe notable improvements in these categories, as demonstrated below.</p>
<section id="width" class="level2">
<h2 class="anchored" data-anchor-id="width">Width</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig7.png" class="img-fluid figure-img" width="1078"></p>
<figcaption>Figure 6: ML estimates for r.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="depth" class="level2">
<h2 class="anchored" data-anchor-id="depth">Depth</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig8.png" class="img-fluid figure-img" width="1093"></p>
<figcaption>Figure 6: ML estimates for r.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="shape" class="level2">
<h2 class="anchored" data-anchor-id="shape">Shape</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig9.png" class="img-fluid figure-img" width="1101"></p>
<figcaption>Figure 6: ML estimates for r.</figcaption>
</figure>
</div>
</div>
</div>
<p>It was found that the previously used quantile transformation resulted in a gap in model prediction between r = 2-9. This occurs because the transformation maps sparse data regions to very small quantile range and was remedied in updated iterations by substituting it with log transformation. This update alone is significant to the impacts of the current model.</p>
</section>
</section>
<section id="final-data-access" class="level1">
<h1>Final Data Access</h1>
<p>The final input data can be found <a href="https://raw.githubusercontent.com/lynker-spatial/mip-riverml/refs/heads/main/data/riverML_ripple_beta_units.parquet">here</a></p>
<p>The final predicted data can be found <a href="https://raw.githubusercontent.com/lynker-spatial/mip-riverml/refs/heads/main/data/riverML_ripple_beta_predictions.parquet">here</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>